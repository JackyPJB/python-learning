#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
-------------------------------------------------

    @   Author  :       pengj
    @   date    :       2018/12/1 22:19
    @   IDE     :       PyCharm
    @   GitHub  :       https://github.com/JackyPJB
    @   Contact :       pengjianbiao@hotmail.com
-------------------------------------------------
    Description :  864. 获取所有钥匙的最短路径

    用户通过次数 0
    用户尝试次数 4
    通过次数 0
    提交次数 6
    题目难度 Hard

给定一个二维网格 grid。 "." 代表一个空房间， "#" 代表一堵墙， "@" 是起点，（"a", "b", ...）代表钥匙，（"A", "B", ...）代表锁。

我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。

假设 K 为钥匙/锁的个数，且满足 1 <= K <= 6，字母表中的前 K 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。

返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。



示例 1：

输入：["@.a.#","###.#","b.A.B"]
输出：8

示例 2：

输入：["@..aA","..B#.","....b"]
输出：6



提示：

    1 <= grid.length <= 30
    1 <= grid[0].length <= 30
    grid[i][j] 只含有 '.', '#', '@', 'a'-'f' 以及 'A'-'F'
    钥匙的数目范围是 [1, 6]，每个钥匙都对应一个不同的字母，正好打开一个对应的锁。
-------------------------------------------------
"""
import time

__author__ = 'Max_Pengjb'
start = time.time()


# 下面写上代码块
class Solution(object):
    def shortestPathAllKeys(self, grid):
        """
        :type grid: List[str]
        :rtype: int
        """
https://leetcode-cn.com/contest/weekly-contest-92/problems/shortest-path-to-get-all-keys/
解答

要求最短路径，采用广度优先搜索。用队列实现广度优先搜索。
因为增加了钥匙，所以我们需要引入状态，以表达当前有多少钥匙。

在同一个位置，若拥有的钥匙数目不同，则视为不同的状态，这些状态需要入队;
若当前状态此前已经访问过（即钥匙数与坐标位置都相同视为同一个状态），则可跳过，无需访问。

key只有6种，我们用一个int类型保存当前已经拥有的key的情况，只需要6bit。
我们从起点开始搜索，遇到钥匙就更新记录，遇到墙就跳过，遇到門若有钥匙则通过，若没有钥匙则跳过。此外，如果当前
状态已经遍历过，就跳过，否则加入队列，这些属于广度优先搜索的基本操作。
---------------------
作者：goodluckcwl
来源：CSDN
原文：https://blog.csdn.net/u014230646/article/details/81189340
版权声明：本文为博主原创文章，转载请附上博文链接！

# 上面中间写上代码块
end = time.time()
print('Running time: %s Seconds' % (end - start))
